1. Чтобы подготовить форму для отправки данных в обработчик, нужно обязательно указать ссылку на сам обработчик в атрибуте "action" и указать method = post или method = get. А еще в форме должна присутствовать кнопка с типом "submit" <button type="submit">, чтобы данные из формы отправлялись в обработчик при клике на нее.

2. Обработчик - это php файл, принимает данные от формы при клике на кнопку <button type="submit"> и выполняет задачи в зависимости от задания. Это может быть запись, чтение или удаление данных в базе данных. А так же обработчик может записывать данные в глобальный массив $_SESSION. Обработчик выделяют в отдельный файл для того, чтобы он исполнялся при нажатии на кнопку в форме. А так же такой PHP код удобнее читать, так как он выделен в отдельный PHP файл.

3. Существует два метода отправки данных через форму: method="GET" и metod="POST". Разница в них заключается в том, что метод "GET" отправляет данные через URL запрос и такие данные можно видеть через адресную строку, а метод "POST" отправляет данные в теле запроса и отправляемые данные не видно в URL запросе и в адресной строке, что делает метод POST более безопасным. А еще метод "POST" поддерживает передачу файлов через форму при использовании кодирования multipart/form-data. Метод "GET" передачу фалов через форму не поддерживает.

4. Процесс записи данных в базу данных: 
	1) Создаем PDO объект в котором подключаемся к базе данных, для этого указываем адрес базы данных, логин и пароль.
		$pdo = new PDO("mysql:host=localhost;dbname=my_project;", "root", "");
	2) Создаем sql запрос и записываем его в переменную. В запросе указываем название таблицы и поля в которые будем записывать данные, а еще указываем переменные, из какоторых будем записывать дынне в поля таблицы.
		$sql = "INSERT INTO task_17_18_register_auth (`name`, `email`, `password`) VALUES (:name, :email, :password)";
	3) Далее идет подготовка запроса в котором мы передаем переменную sql содержащую текст запроса.
		$statement = $pdo->prepare($sql);
	4) Далее выполнение запроса, в котором мы указываем переменные, содержащие данные. 
		$statement->execute(['name' => $name, 'email' => $email, 'password' => $hashed_password]);

5.	Для создания флещ-сообщений мы используем глобальный массив $_SESSION['message'], в поле 'message' которого мы записываем текст сообщения в коде обработчика, затем передает текст сообщения на основную страницу и на основной странице его показываем. 

6. Запускаем функцию session_start() в коде основной страницы и в коде обработчика, для того чтобы работал глобальный массив $_SESSION. Далее передаем данные данные из формы в обработчик, в котором происходит выполнение php кода и в результате его выполнения мы пишем условие. Если например в базе не найдем пользователь с данным именем, то в обработчие мы записываем сообщение: $_SESSION['message'] = "Пользователь не найден". Далее через глобальный массив $_SESSION мы выводим данное сообщение на основной странице. Для этого мы проверяем уловие <?php if(isset($_SESSION['message'])):?>, то мы выводим текст сообщения через <?php echo $_SESSION['message'];?> и далее мы удаляем элемент массива $_SESSION, через <?php unset($_SESSION['message']);?> для того, чтобы при обновлении страницы, текст сообщения не выводился.

7. Текст на формат email адреса средствами php можно проверить следующим образом. В email адресе есть символ "@". Мы можем проверить его наличие при помощи функции srtpos(). Вот пример кода.
<?php
$email = "mail_ru@example.com";

$find = "@";

$check = strpos($email, $find);

if($check === false) {echo "Данная строка не является email адресом";}

else {echo "Данная строка является email";}
?>

8. Для генерации хеша пароля при создании регистрации, используется функция password_hash(), а для проверки пароля при авторизаци, используется функция password_verify().

9. Пароль необходимо хранить в виде хеша, а не записывать в открытом виде, так как это нужно для безопасности. Так как в хешированном виде сам пароль невозможно узнать, даже если злоумышленник доберется до базы данных и узнает хеш пароля, то восстановить пароль их хеша он не сможет. 

10. Сессия нужна для того, чтобы передавать данные между веб-страницами в пределах одного сеанса связи пользователя. Сессия представляет из себя массив $_SESSION, в поля которого можно сохранять данные об авторизации пользователя и информационные сообщения, которые мы хотим передать от обработчиков к веб-страницам, чтобы вывести их на экран.

11. Функционал аутентификации пошагово:
	1) Допустим, у нас уже есть зарегистрированный на сайте пользователь, логин и пароль которого сохранены в базу данных. Пароль сохранен в хешировнном виде.
	2) Мы создаем форму на странице аутентификации, прописываем поля email и пароля. В качестве объекта action формы, мы указываем php файл обработчика, в качестве метода мы указываем метод POST, в кнопке отправки формы, мы указываем <button type="submit">.
	3) В php файле обработчика мы получаем email и пароль из формы в массиве $_POST.
	4) Далее в обработчике мы подключаемся к базе данных, используя адрес базы данных, логин и пароль.
	5) Далее создаем sql запрос, в котором прописываем прописываем чтение строки а базе данных, в которой email пользователя равен тому email, который мы передали от формы в массиве $_POST. И записываем результат массив $user.
	6) Далее мы создаем условие в котором проверяем, если массив $user пустой, то есть пользователь с таким email не найден, то мы записываем сообщение 
	в $_SESSION['message'], что была ошибка ввобда email или пароля, чтобы показать это сообщение на странице авторизации, и переадресовываем на страницу авторизации.
	7) Если пользователь с таким email был найден, то мы проверяем пароль, используя функцию password_verify, в которую передаем введенный пароль из формы, который записан в массиве $_POST и прочитанный хеш пароля из базы данных. Если функция после проверки пароля выдает сообщение, что пароль не верный, то мы так же записываем сообщение в $_SESSION['message'], что была ошибка ввобда email или пароля и переадресовываем на страницу авторизации.
	8) Если в результате выполнения функции password_verify пароль был верный, то мы записываем в массив $_SESSOON информацию об имени пользователя и переадресовываем пользователя на странцу сайта. Пользователь считается авторизованным, пока в сессии хранится информация о его имени пользователя.

12. Для загрузки файлов форма должна быть настроена на отправку данных только путем метода POST. В форме должен быть прописан enctype="multipart/form-data". А так же должен использоваться <input type="file">.

13. Для множественной загрузки файлов у input должен быть атрибут name с именем, содержащим в конце квадратные скобками, как у массива. Например: <input type="file" name="image[]">.

14. Чтобы создать уникальное название файла, нужно сгенерировать уникальное имя файла при помощи функции uniqid(), сохраняя оригинальное расширение файла и затем после загрузки файла во временную директорию на сервере, переименовать файл используя сгенерированное уникальное имя.

15. Для загрузки файла мы создавали функцию upload_file(), внутри которой мы использовали функции: pathinfo() - возврат информации о пути к файлу, uniqid() - генерирует уникальное имя файла, move_uploaded_file() - переносит загруженный на сервер файл в указанную директорию и переименовывает файл. Для проверки, существует ли файл в папке, иы использовали функцию file_exists(). Для удаления файла мы использовали функцию unlink().

16. Глобальный массив $_FILES хранит все файлы, передаваемые через форму.

17. Глобальный массив $_FILES хранит в себе несколько вложенных массивов, каждый из которых может хранить несколько пронумерованных ключей, с именами, называющимися цифрами, начинающимися от 0, и значениями записанными в эти ключи. В глобальном массиве $_FILE вложены следующие массивы: 
	1) Массив "name" - содержим имена передаваемых файлов.
	2) Массив "full_path" - содержит полные пути до файлов на диске.
	3) Массив "type" - содержит тип файла.
	4) Массив "tmp_name" - содержит путь и имя временного файла, в которые загружаются файлы через форму на сервер.
	5) Массив "error" - содержит коды ошибки, которе могут возникнуть в случае невозможности загрузки файлов на сервер.
	6) Массив "size" - содержит размер загружаемых файлов в байтах.


18. В данном примере ошибка может быть в ненаписанной или неправильно написанной функции "files_to_dbase", которой передается имя файла, для записи в базу данных. А так же в том, что имя файла для записи в базу данных может в эту функцию не передаваться в коде в момент вызова функции.

19. Ошибка "illegal offset type" возникает, когда идет доступ к элементу массива и в качестве ключа элемента массива используется другой массив или объект класса. Нужно исправить ошибку в коде, чтобы в качестве ключа элемента массива использовалось целое число или строка.

20. В данном примере допущена синтаксическая ошибка, пропущена одна из скобок. Нужно проверить PHP файл на наличие синтаксических ошибок.

21. Нужно проверить в форме, которая передает данные в обработчик, должен быть подключен PHP файл обработчика и должен быть указан method="POST". А так же у кнопки, которая отправляет данные формы, должен быть указан button type="submit".

22. Технически глобальные массивы отличаются от обычных массивов тем, что глобальные массивы хранят и передают данные между несколькими PHP файлами. А обычные массивы хранят и передают данные только в пределах одного исполняемого PHP файла.

23. Мой совет таков: переменным и массивам нужно давать осознанные имена, в соответствие с тем, для чего используется данная переменная, и соответсвенно для чего используется данный массив. Чтобы код позже был понятен и легко читаем для любого программиста.

24. Мой совет таков: начинать писать авторизацию нужно со страницы ввода логина и пароля, на которой должна быть ссылка на страницу регистрации. Если у пользователя нет логина и пароля, то пользователь сможет зарегистрироваться. На странице авторизации пользователь вводит логин и пароль в форму, к которой подключен php файл обработчика. Форма при помощи метода $_POST передает данные в обработчике, в котором идет подключение к базе данных и идет проверка сначала логина, а затем пароля. Если учетная запись, содержащая логин и пароль найдена, то данные учетной записи из базы данные записываются в переменную в массиве $_SESSION. И дале идет переадресация на страницу авторизованного пользователя. Если введенные логин или пароль не совпадают с учетной записью в базе данных, то записывается флеш сообщение, в переменную в массив $_SESSION и идет переадресация на страницу авторизации, на которой выводится флеш сообщение, что логин или пароль не верные. Для написания страницы регистрации принцип похожий. Данные из формы на странице регистрации передаютс в php файл обработчика, при помощи массива $_POST. Далее в обработчике идет проверка на существование уже такой учетной записи с данным логином в базе данных. Если такой учетной записи нет, то происходит создание новой записи в базе данных, в которую записываются логин и пароль пользователя. Пароль записывается в захешированном виде. Если все таки учетная запись с таким логином уже есть, то в массив $_SESSION записывается флеш сообщение, происходит переадресация на страницу регистрации, на которой выводится флеш сообщение.

25. Массивы $_SESSION и $_COOKIE используются для создания авторизации на сайте. Массив $_SESSION хранит информацию в оперативной памяти и удаляется, при перезагрузке страниц или при перезапуске браузера. Массив $_SESSION доступен на всех страницах сайта, на которых запущена функция session_start(). Массив $_COOKIE хранит информацию в браузере и сохраняется при перезагрузке страниц или при перезапуске браузера, до тех пор, пока не истечет срок жизни $_COOKIE.

26. Я бы дал человеку совет: проходить курс нужно вдумчиво, шаг за шагом. Если что то не понятно, то пересматривать видео уровки по несколько раз, повторять все действия за преподавателем. Задавать вопросы, если что то не понятно, до полного понимания материала.

27. У меня положительные впечатления от первой части практики. Задания были сложные, приходилось много думать, по несколько раз пересматривать видео уроки. Но зато было очень интересно проходить данный модуль.